Install EKSCTL
brew tap weaveworks/tap
brew install weaveworks/tap/eksctl

aws ec2 create-key-pair --region us-west-2 --key-name <myKeyPair>
eksctl create cluster \
    --name test-cluster
    --version 1.17 \
    --region us-east-2 \
    --with-oidc \
    --ssh-access \
    --ssh-public-key <your-key> \
    --nodegroup-name linux-nodes \
    --node-type t2-medium \
    --nodes 2
    --managed

kubectl get nodes -o jsonpath='{.items[*].status.addresses[?(@.type=="ExternalIP")].address}'
eksctl delete cluster --name test-cluster --region us-east-2
kubectl describe service demo -n default
kubectl get endpoints

kubectl exec -it node-app-8649b55857-zds5t /bin/bash/
kubectl exec -it node-app-8649b55857-zds5t /bin/sh

apt add curl
curl http://kubernetes.default.svc.cluster.local
curl http://kubernetes.default
ping demo.default.svc.cluster.local

minikube addons list
minikube addons enable <addon>


Once you know the IP (of Ingress), you can then either configure your DNS servers to resolvekubia.example.com
to that IP or you can add the following line to /etc/hosts
(orC:\windows\system32\drivers\etc\hosts on Windows):

192.168.99.100    kubia.example.com

ACCESSING PODS THROUGH THE INGRESS
Everything is now set up, so you can access the service at http://kubia.example.com(using a browser or curl):
$ curl http://kubia.example.com


For now, you’ll create theSecret without paying too much attention to it.
First, you need to create the private key and certificate:

openssl genrsa -out tls.key 2048
openssl req -new -x509 -key tls.key -out tls.cert -days 360 -subj /CN=demo.example.com
kubectl create secret tls tls-secret --cert=tls.cert --key=tls.key

curl -k -v https://demo.example.com/kubia
* About to connect() to kubia.example.com port 443 (#0)
...
* Server certificate:
*   subject: CN=demo.example.com.
..
> GET /kubia HTTP/1.1
>

kubectl exec demo-deployment-pod-559cbd5846-5fvn7 -- touch /var/ready

Run a pod pod based on an image that contains the binaries you need?
To perform DNS-related actions, you can use the tutum/dnsutils containerimage,
which is available on Docker Hub and contains both the nslookup and the dig binaries.

$ kubectl run dnsutils --image=tutum/dnsutils --generator=run-pod/v1 --command -- sleep infinity

Perform DNS lookup inside the Pod.
$ kubectl exec dnsutils nslookup demo-headless

The DNS server returns two different IPs for the kubia-headless.default.svc.cluster.local FQDN.
Those are the IPs of the two pods that are reporting beingready. You can confirm this by listing pods with kubectl get pods -o wide, whichshows the pods’ IPs.

Look up clusterIP. Headless is different from what DNS returns for regular services such as for clusterIP service, where the returned IP is the service's clusterIP.
$ kubectl exec dnsutils nslookup demo-clusterIP

name:    kubia.default.svc.cluster.local
Address: 10.111.249.153

kubectl get pods -o yaml | grep -i podip
curl -k https://172.17.0.3

kubectl port-forward fortune 8080:80
curl http://localhost:8080


Look at volumes of pods
kubectl get pods -n kube-system
kubectl describe pod kube-controller-manager-minikube -n kube-system

Create GCE Persistant Disk 
$ gcloud container cluster list
$ gcloud compute disks create --size=1GiB --zone=us-east1-c mongodb


WRITING DATA TO THE PERSISTENT STORAGE BY ADDING DOCUMENTS TO YOUR MONGODB DATABASe
$ kubectl exec -it mongodb mongo
or
$ kubectl exec -it mongodb -- mongo
> use mystore
> db.foo.insert({name: 'foo'})
> db.foo.find()

See docker processes runnning in container"
$ docker exec 4675d ps
$ docker exec -it e4bad ps x

ConfigMaps
$ kubectl create configmap fortune-config --from-literal=sleep-interval=25

From file:
$ kubectl create configmap my-config --from-file=config-fil.conf


When you run the previous command, kubectl looks for the file config-file.conf inthe directory you run kubectl in.
It will then store the contents of the file under thekey config-file.conf in the ConfigMap (the filename is used as the map key),
but you can also specify a key manually like this:

$ kubectl create configmap my-config --from-file=customkey=config-file.conf

This command will store the file’s contents under the key customkey.
As with literals,you can add multiple files by using the --from-file argument multiple times.

------------------------------------------------------------------------

Youtube GKE cluster video:
https://www.youtube.com/watch?v=Vcv6GapxUCI&t=35s

gcloud organizations list
gcloud beta billing accounts list

export TF_VAR_org_id=YOUR_ORG_ID
export TF_VAR_billing_account=YOUR_BILLING_ACCOUNT_ID
export TF_ADMIN=${USER}-terraform-admin
export TF_CREDS=~/.config/gcloud/${USER}-terraform-admin.json

Connect cluster to local machine
$ gcloud container clusters get-credentials k8-cluster-project-gke-cluster-default --zone us-central1-c --project k8-cluster-project

List clusters and info (to find info, like zone etc...)
$ gcloud container clusters list

Create a GCE PersistantDisk. This is Provisioning the storge manually.
$ gcloud compute disks create --size=10GB --zone=us-central1-c mongodb

Authenticating and OAuth with service account:
If you're running Terraform from a GCE instance, default credentials are automatically available. See Creating and Enabling Service Accounts for Instances for more details.
On your computer, you can make your Google identity available by running gcloud auth application-default login.

kubectl config view -o jsonpath='{.users[*].name}'
kubectl config view -o jsonpath='{.users[?(@.name == "gke_k8-cluster-project_us-central1-c_kubia")].user.password}'
kubectl config view -o jsonpath='{.users[?(@.name == gke_k8-cluster-project_us-central1-c_kubia)].user.password}'
kubectl config view -o jsonpath='{.users[?(@.name == "gke_k8-cluster-project_us-central1-c_kubia")].user.password}'
kubectl config view

kubectl get secrets

Kubernetes Dashboard
kubectl proxy http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/
kubectl cluster-info
kubectl create -f https://raw.githubusercontent.com/kubernetes/dashboard/master/aio/deploy/recommended/kubernetes-dashboard.yaml\n
kubectl proxy http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/
kubectl proxy http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/\#/login
kubectl describe secrets
kubectl proxy http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/\#/login

minikube addons list
minikube addons enable <addon>

minikube kubernetes Dashboard
minikube dashboard
minikube dashboard --url

kubectl get pods --all-namespaces
kubectl get secret -n kubernetes-dashboard -o yaml

kubectl describe pod kubernetes-dashboard-9f9799597-vmdm7 -n kubernetes-dashboard
kubectl cluster-info

kubectl get pods --show-labels
kubectl get jobs
kubectl api-resources -o name
kubectl api-resources --namespaced=true

kubectl get events --sort-by=.metadata.creationTimestamp

kubectl config view -o jsonpath='{.users[*].name}'
kubectl config current-context

kubectl cluster-info
kubectl cluster-info dum
kubectl cluster-info dump
kubectl cluster-info dump > cluster.txt



$ kubectl create configmap fortune-config --from-file=configmap-files
$ kubectl get configmap fortune-config -o yaml


$ kubectl port-forward fortune-configmap-volume 8080:80 &
$ curl -H "Accept-Encoding: gzip" -I localhost:8080
$ kubectl exec fortune-nginx-configmap-volume -c web-server ls /etc/nginx/conf.d
$ kubectl edit configmap fortune-config
$ kubectl exec fortune-configmap-volume -c web-server -- cat /etc/nginx/conf.d/my-nginx-config.conf
$ kubectl exec fortune-configmap-volume -c web-server -- nginx -s reload
$ kubectl exec -it fortune-configmap-volume -c web-server -- ls -lA
$ kubectl exec -it fortune-configmap-volume -c web-server -- ls -lA /etc/nginx/conf.d


secrets
$ kubectl exec demo-deployment-pod-559cbd5846-gth6v ls  /var/run/secrets/kubernetes.io/serviceaccount
Create secret for https traffic

$ openssl genrsa -out https.key 2048
$ openssl req -new -x509 -key https.key -out https.cert -days 3650 -subj /CN=www.kubia-example.com
$ echo bar > foo

Now you can use kubectl create secret to create a Secret from the three files:
$ kubectl create secret generic fortune-https --from-file=https.key➥  --from-file=https.cert --from-file=foo

kubectl exec fortune-https -c web-server -- mount | grep certs

Pull image from docker from private repository
$ kubectl create secret docker-registry mydockerhubsecret \
    --docker-username=myusername \
    --docker-password=mypassword \
    --docker-email=my.email@provider.com


Looking at volumes in container of downward api volume
$ kubectl exec downward -- ls -alh /etc/downward
$ kubectl exec downward -- cat /etc/downward/labels
$ kubectl exec downward -- cat /etc/downward/annotations
